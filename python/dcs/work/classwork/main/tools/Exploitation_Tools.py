from main.tools import run_on_browser,banner,PostExploitationAttacks,waiting,writeup,colors
import os
import subprocess
import threading
import time
import requests
from bs4 import BeautifulSoup

def check_installed(name,needargs=False):
    proc = subprocess.Popen([f"dpkg -s {name} 2>/dev/null"], stdout=subprocess.PIPE, shell=True)
    #there keyfor success output and noththere for error output
    (there, notthere) = proc.communicate()
    if "install ok installed" not in there.decode():
                print(f"{colors.red}[-] Not Installed")
                print(f"[+] It Is Not Ynstalled In Your Kali{colors.reset}")
                download=input(f"{colors.blue}[+] Do You Want To Install It?(y/n): {colors.reset}")
                if download=="y" or download=="Y" or download=="Yes" or download=="yes":
                    os.system(f"apt install {name} -y")
                    if needargs:
                        download=input(f"{colors.green}Do You Want To Run The Tool?(y/n): {colors.reset}")
                        if download=="y" or download=="Y" or download=="Yes" or download=="yes":
                            os.system(f"{name} > /dev/null 2>&1")
                            #when tool is of cli no need of thread
                            thread_run(name,needargs)
                    else:
                        download=input(f"{colors.blue}Do You Want To Run The Tool?(y/n): {colors.reset}")
                        if download=="y" or download=="Y" or download=="Yes" or download=="yes":
                            os.system(f"{name} > /dev/null 2>&1")
                            #when tool is of gui it needs thread
                            threading.Thread(target=thread_run, args=(name,)).start()
    else:
                print(f"{colors.green}[+] Installed")
                print(f"[+] It Is Installed In Your Kali{colors.reset}")
                if needargs:
                        download=input(f"{colors.green}Do You Want To Run The Tool?(y/n): {colors.reset}")
                        if download=="y" or download=="Y" or download=="Yes" or download=="yes":
                            #when tool is of cli no need of thread
                            os.system(f"{name} > /dev/null 2>&1")
                            thread_run(name,needargs)
                else:
                        download=input(f"{colors.green}Do You Want To Run The Tool?(y/n): {colors.reset}")
                        if download=="y" or download=="Y" or download=="Yes" or download=="yes":
                           os.system(f"{name} 2>/dev/null")
                            #when tool is of gui it needs thread
                            # threading.Thread(target=thread_run, args=(name,)).start()
def thread_run(command,needargs=False):
    if needargs=="no-help":
        #it will run only help because it is in cli
        os.system(f"{command}")
    elif needargs:
        os.system(f"{command} -h")
    else:
        #for gui all errors/output will go in null 
        os.system(f"{command} > /dev/null 2>&1")

def github_getting_text(link,selector,indexvalue):
    print("Please Wait....\r",end="")
    URL = link
    try:
        r = requests.get(URL)
        soup = BeautifulSoup(r.content, 'html5lib')
        paras = soup.select(selector)
        #check index value from test file
        return paras[indexvalue].text
    except:
        return "Not loaded because no internet connection"

def main():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Exploitation Tool")
        list_attacks=["Metasploit","CrackMapExec","Searchsploit","BeEF","RouterSploit","sqlmap","Armitage","Commix","go back"]
        for i in range(len(list_attacks)):
                print(colors.options,f"{i}) {list_attacks[i]}".title(),colors.reset)
        option = input(f"\n {colors.select}Select An Option ->{colors.reset}  ")
        if option=="0":
            print("\n[+] Metasploit")
            os.system("clear")
            PostExploitationAttacks.MetasploitFramework()
        elif option=="1":
            print("\n[+] CrackMapExec")
            os.system("clear")
            CrackMapExec()
        elif option=="2":
            print("\n[+] Searchsploit")
            os.system("clear")
            Searchsploit()
        elif option=="3":
            print("\n[+] BeEF")
            os.system("clear")
            BeEF()
        elif option=="4":
            print("\n[+] RouterSploit")
            os.system("clear")
            Routersploit()
        elif option=="5":
            print("\n[+] sqlmap")
            os.system("clear")
            sqlmap()
        elif option=="6":
            print("\n[+] Armitage")
            os.system("clear")
            Armitage()
        elif option=="7":
            print("\n[+] Commix")
            os.system("clear")
            Commix()
        else:
            return


def CrackMapExec():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("CrackMapExec")
        banner.description("CrackMapExec (a.k.a CME) is a post-exploitation tool that helps automate assessing the security of large Active Directory networks. Built with stealth in mind, CME follows the concept of Living off the Land : abusing built-in Active Directory features/protocols to achieve it's functionality and allowing it to evade most endpoint protection/IDS/IPS solutions.")
        ask=tool_writeups()
        if ask=="1":
            print(f"{colors.blue}[+] Download/Usage")
            print(f"\nPreinstalled In Repository{colors.reset}")
            check_installed("crackmapexec",True)
            waiting.waiting()
        elif ask=="2":
            writeup.writeup({"CrackMapExec in Kali Linux":"https://www.kali.org/tools/crackmapexec/","How to Use CrackMapExec":"https://blog.netwrix.com/2022/12/16/crackmapexec_tutorial/","Lateral Movement on Active Directory: CrackMapExec":"https://www.hackingarticles.in/lateral-moment-on-active-directory-crackmapexec/","CrackMapExec Cheat sheet":"https://cheatsheet.haax.fr/windows-systems/exploitation/crackmapexec/"},"Crackmapexec writeup.writeup")
        else:
            return


def Searchsploit():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Searchsploit")
        banner.description("The Exploit Database is an archive of public exploits and corresponding vulnerable software, developed for use by penetration testers and vulnerability researchers. Its aim is to serve as the most comprehensive collection of exploits, shellcode and papers gathered through direct submissions, mailing lists, and other public sources, and present them in a freely-available and easy-to-navigate database.")
        ask=tool_writeups()
        if ask=="1":
            ask_install=input(f"{colors.blue}[+] Do you want to install Searchsploit or not?(y/n): {colors.reset}")
            if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                proc = subprocess.Popen([f"dpkg -s exploitdb 2>/dev/null"], stdout=subprocess.PIPE, shell=True)
                #there keyfor success output and noththere for error output
                (there, notthere) = proc.communicate()
                if "install ok installed" not in there.decode():
                    print(f"{color.green}[-] not installed")
                    print(f"[+] it is not installed in your Kali{colors.reset}")
                    download=input(f"{colors.blue}[+] Do you want to install it?(y/n): {colors.reset}")
                    if download=="y" or download=="Y" or download=="Yes" or download=="yes":
                        os.system(f"apt install exploitdb -y")
                        download=input(f"{colors.green}Do You Want To Run The Tool?(y/n): {colors.reset}")
                        if download=="y" or download=="Y" or download=="Yes" or download=="yes":
                            #when tool is of cli no need of thread
                            print("\n")
                            os.system("searchsploit")
                            waiting.waiting()
                        else:
                            pass
                else:
                    print(f"{colors.green}[+] Installed")
                    print(f"[+] It Is Installed In Your Kali{colors.reset}")
                    download=input(f"{colors.green}Do You Want To Run The Tool?(y/n): {colors.reset}")
                    if download=="y" or download=="Y" or download=="Yes" or download=="yes":
                        #when tool is of cli no need of thread
                        print("\n")
                        os.system("searchsploit")
                        waiting.waiting()
                    else:
                        pass
            else:
                pass
        elif ask=="2":
            writeup.writeup({"How to install Searchsploit":"https://www.exploit-db.com/searchsploit","How to Use SearchSploit":"https://www.kali.org/tools/exploitdb/#searchsploit","Finding Exploit offline using Searchsploit in Kali Linux":"https://www.geeksforgeeks.org/finding-exploit-offline-using-searchsploit-in-kali-linux/","How to easy find exploits with Searchsploit on Linux":"https://medium.com/@hninja049/how-to-easy-find-exploits-with-searchsploit-on-linux-4ce0b82c82fd"},"Searchsploit writeup.writeup")
        else:
            return



def BeEF():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("BeEF")
        banner.description('''The Browser Exploitation Framework (BeEF) is a powerful and intuitive security tool. BeEF is pioneering techniques that provide penetration testers with practical client-side attack vectors. Unlike other security frameworks, BeEF focuses on leveraging browser vulnerabilities to assess the security posture of a target. This project is developed solely for lawful research and penetration testing.

BeEF hooks one or more web browsers to the application for the launching of directed command modules. Each browser is likely to be within a different security context, and each context may provide a set of unique attack vectors. The framework allows the penetration tester to select specific modules (in real-time) to target each browser, and therefore each context.

The framework contains numerous command modules that employ BeEF's simple and powerful API. This API is at the heart of the framework's effectiveness and efficiency. It abstracts complexity and facilitates quick development of custom modules.''')
        ask=tool_writeups()
        if ask=="1":
            print(f"{colors.blue}[+] Download/Usage")
            print(f"\nPreinstalled In Repository{colors.reset}")
            check_installed("beef",True)
            waiting.waiting()
        elif ask=="2":
            writeup.writeup({"BEeF Hacking Framework Tutorial [5 Easy Steps]":"https://www.golinuxcloud.com/beef-hacking-framework-tutorial/","Browser Exploitation and Advanced Threat Actors: An Overview of BeEF":"https://medium.com/@andrearebora/browser-exploitation-and-advanced-threat-actors-an-overview-of-beef-bb907a5b73fa","Hooking victims to Browser Exploitation Framework (BeEF) using Reflected and Stored XSS.":"https://medium.com/@secureica/hooking-victims-to-browser-exploitation-framework-beef-using-reflected-and-stored-xss-859266c5a00a","Hijacking Browser with BeEF Framework":"https://medium.com/@krunalkumarpatel/hijacking-browser-with-beef-framework-bea784c03149"},"Beef writeup.writeup")
        else:
            return


def Routersploit():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Routersploit")
        banner.description("The RouterSploit Framework is an open-source exploitation framework dedicated to embedded devices. It consists of various modules that aid penetration testing operations: exploits - modules that take advantage of identified vulnerabilities. creds - modules designed to test credentials against network services.")
        ask=tool_writeups()
        if ask=="1":
                print(f"{colors.blue}[+] Download/usage")
                print(f"\nPreinstalled in Repository{colors.reset}")
                # print("\n Go to Application section and search for `zap`")
                check_installed("routersploit")
        elif ask=="2":
            writeup.writeup({"How to Use Routersploit":"https://www.kali.org/tools/routersploit/","Routersploit Tutorial":"https://kalitut.com/routersploit/","RouterSploit User Manual":"https://miloserdov.org/?p=1527"},"Routersploitwriteup")
        else:
            return
            


def sqlmap():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("sqlmap")
        banner.description("sqlmap is an open source penetration testing tool that automates the process of detecting and exploiting SQL injection flaws and taking over of database servers. It comes with a powerful detection engine, many niche features for the ultimate penetration tester and a broad range of switches lasting from database fingerprinting, over data fetching from the database, to accessing the underlying file system and executing commands on the operating system via out-of-band connections")
        ask=tool_writeups()
        if ask=="1":
            print(f"{colors.blue}[+] Download/Usage")
            print(f"\nPreinstalled In Repository{colors.reset}")
            check_installed("sqlmap",True)
            waiting.waiting()
        elif ask=="2":
            writeup.writeup({"Usage Of Sqlmap":"https://github.com/sqlmapproject/sqlmap/wiki/Usage","How to use SQLMAP to test a website for SQL Injection vulnerability":"https://www.geeksforgeeks.org/use-sqlmap-test-website-sql-injection-vulnerability/","How to Use SQLMap to Find Database Vulnerabilities":"https://www.freecodecamp.org/news/how-to-protect-against-sql-injection-attacks/","SQLMap - Cheetsheat":"https://book.hacktricks.xyz/pentesting-web/sql-injection/sqlmap",},"Sqlmap writeup.writeup")
        else:
            return

def Commix():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Commix")
        banner.description("Commix (short for [comm]and [i]njection e[x]ploiter) is an open source penetration testing tool, written by Anastasios Stasinopoulos (@ancst), that automates the detection and exploitation of command injection vulnerabilities.")
        ask=tool_writeups()
        
        if ask=="1":
            print(f"{colors.blue}[+] Download/Usage")
            print(f"\nPreinstalled In Repository{colors.reset}")
            check_installed("commix",True)
            waiting.waiting()
        elif ask=="2":
            writeup.writeup({"Commix Usage Example":"https://www.kali.org/tools/commix/","OS Command Injection and Exploitation Tool":"https://www.geeksforgeeks.org/commix-os-command-injection-and-exploitation-tool/"," an automated tool for command injection":" an automated tool for command injection"},"Commix writeup.writeup")
        else:
            return

def Armitage():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Armitage")
        banner.description("Armitage is a fantastic Java-based GUI front-end for the Metasploit Framework developed by Raphael Mudge. Its goal is to help security professionals better understand hacking and help them realize the power and potential of Metasploit.")
        ask=tool_writeups()
        if ask=="1":
            print(f"{colors.blue}[+] Download/Usage")
            print(f"\nPreinstalled In Repository{colors.reset}")
            check_installed("armitage",True)
            waiting.waiting()
        elif ask=="2":
            writeup.writeup({"How to Install Armitage on Kali Linux":"https://linuxhint.com/install-armitage-kali-linux/","Armitage Setup":"https://www.offensive-security.com/metasploit-unleashed/armitage-setup/","Hacking With Armitage on Kali Linux / Backtrack ":"https://www.amirootyet.com/post/hacking-with-armitage-on-kali-linux/"},"Armitage writeup.writeup")
        else:
            return

def tool_writeups():
    print(f"{colors.options}1) TOOL(About,Installation)")
    print("2) Write Ups")
    print("3) Go Back..")
    ask=input(f"\n {colors.select}Select An Option ->{colors.reset}  ")
    return ask

if __name__ == "__main__": 
    main()
