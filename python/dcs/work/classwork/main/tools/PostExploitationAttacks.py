from collections.abc import Collection
from main.tools import banner,waiting,writeup,colors
import os
import subprocess
import requests
from bs4 import BeautifulSoup

def check_installed(name, run_arg):
    proc = subprocess.Popen([f"dpkg -s {name} 2>/dev/null"], stdout=subprocess.PIPE, shell=True)
    (there, notthere) = proc.communicate()
    if "install ok installed" not in there.decode():
        os.system(f"apt install {name} -y")
        download = input(f"{colors.blue}Do You Want To Run The Tool?(y/n):{colors.reset}")
        if download == "y" or download == "Y" or download == "Yes" or download == "yes":
            os.system(f"{run_arg}")
    else:
        print(f"{colors.green}[+] Installed")
        print(f"[+] It Is Installed In Your Kali{colors.reset}")
        download = input(f"{colors.blue}Do You Want To Run The Tool?(y/n):{colors.reset}")
        if download == "y" or download == "Y" or download == "Yes" or download == "yes":
            os.system(f"{run_arg}")

def github_getting_text(link,selector,indexvalue):
    print("Please Wait....\r",end="")
    URL = link
    try:
        r = requests.get(URL)
        soup = BeautifulSoup(r.content, 'html5lib')
        paras = soup.select(selector)
        #check index value from test file
        return paras[indexvalue].text
    except:
        return f"{colors.red}Not loaded because no internet connection{colors.reset}"

def main():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Post Exploitation")
        text = f"""{colors.options}1) Privilege Escalation
2) Maintain Access
3) Clearing or Removing Tracks
4) go back
        """
        print(text)
        
        stage = input(f"{colors.select} Select options -->{colors.reset}  ")
        
        if stage == "1":
            while True:
                os.system("clear")
                banner.main()
                banner.attack("Post Exploitation")
                banner.attack("Privilege Escalation")
                list_attacks=["Metasploit-Framework","LinPeas","LinEnum","Sudo killer","Beroot","Linux Exploit Suggester 2","LSE (Linux Smart Enumeration) ","PSPY","Bashark","Linux Private-i","Go Back"]
                for i in range(len(list_attacks)):
                    print(colors.options,f"{i}) {list_attacks[i]}".title(),colors.reset)
                option = input(f"\n {colors.select}Select An Option ->{colors.reset}  ")
                if option=="0":
                    print("\n[+] Metasploit-Framework")
                    os.system("clear")
                    MetasploitFramework()
                elif option=="1":
                    print("\n[+] LinPeas")
                    os.system("clear")
                    LinPeas()
                elif option=="2":
                    print("\n[+] LinEnum")
                    os.system("clear")
                    LinEnum()
                elif option=="3":
                    print("\n[+] Sudo killer")
                    os.system("clear")
                    SudoKiller()
                elif option=="4":
                    print("\n[+] Beroot")
                    os.system("clear")
                    Beroot()
                elif option=="5":
                    print("\n[+] Linux Exploit Suggester 2")
                    os.system("clear")
                    LinuxExploitSuggester()
                elif option=="6":
                    print("\n[+] LSE (Linux Smart Enumeration)")
                    os.system("clear")
                    LSE()
                elif option=="7":
                    print("\n[+] PSPY")
                    os.system("clear")
                    PSPY()
                elif option=="8":
                    print("\n[+] Bashark")
                    os.system("clear")
                    Bashark()
                elif option=="9":
                    print("\n[+] Linux Private-i")
                    os.system("clear")
                    LinuxPrivatei()
                else:
                    break
                
        elif stage == "2":
            while True:
                os.system("clear")
                banner.main()
                banner.attack("Post Exploitation")
                banner.attack("Maintain Access")
                list_attacks2=["Metasploit-Framework","Shellter","Amber","UPX (Ultimate Packer for Executable)","Go Back"]
                for i in range(len(list_attacks2)):
                    print(colors.options,f"{i}) {list_attacks2[i]}".title(),colors.reset)
                option = input(f"\n {colors.select}Select An Option ->{colors.reset}  ")
                
                if option=="0":
                    print("\n[+] Metasploit-Framework")
                    os.system("clear")
                    MetasploitFramework()
                elif option=="1":
                    print("\n[+] Shellter")
                    os.system("clear")
                    Shellter()
                elif option=="2":
                    print("\n[+] Amber")
                    os.system("clear")
                    Amber()
                elif option=="3":
                    print("\n[+] UPX (Ultimate Packer for Executable)")
                    os.system("clear")
                    UPX()
                else:
                    break
                    
        elif stage == "3":
            while True:
                os.system("clear")
                banner.main()
                banner.attack("Post Exploitation")
                banner.attack("Clearing or Removing Tracks")
                list_attacks3=["Metasploit-Framework","Covermyass","Go Back"]
                for i in range(len(list_attacks3)):
                    print(colors.options,f"{i}) {list_attacks3[i]}".title(),colors.reset)
                option = input(f"\n {colors.select}Select An Option ->{colors.reset}  ")
                if option=="0":
                    print("\n[+] Metasploit-Framework")
                    os.system("clear")
                    MetasploitFramework()
                elif option=="1":
                    print("\n[+] Covermyass")
                    os.system("clear")
                    Covermyass()
                else:
                    break
        else:
            return

        
def MetasploitFramework():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Metasploit Framework")
        banner.description("The Metasploit Framework is an open-source tool for developing and executing exploit code against a remote target machine. It can be used to test the security of a computer system by finding and exploiting vulnerabilities. The framework includes a large collection of exploit modules, as well as various tools for payload generation, post-exploitation, and more. It can be used by security professionals for penetration testing, as well as by attackers for malicious purposes.\n")
        ask=tool_writeups()
        if ask=="1":
                check_installed("metasploit-framework", "msfconsole")
        elif ask=="2":
            #first argument for dictionary(key=title,value=url) second argument for banner 
            writeup.writeup({"Msf-Community-Post-Exploitation":"https://www.offensive-security.com/metasploit-unleashed/msf-community-post-exploitation","Post Exploitation In Linux With Metasploit":"https://pentestlab.blog/2013/01/04/post-exploitation-in-linux-with-metasploit/","Privilege Escalation (Metasploit Unleashed)":"https://www.offensive-security.com/metasploit-unleashed/privilege-escalation/","Post Exploitation Metasploit Modules (Reference)":"https://www.infosecmatter.com/post-exploitation-metasploit-modules-reference","PSExec Pass the Hash (Horizontal Escalation)":"https://www.offensive-security.com/metasploit-unleashed/psexec-pass-hash/","ms10_002_aurora (Vertical Escalation)":"https://www.offensive-security.com/metasploit-unleashed/privilege-escalation/","ms10_002_aurora (Horizontal Escalation)":"https://www.offensive-security.com/metasploit-unleashed/pivoting/ ","jtr_crack_fast (Hash Cracking)":"https://www.offensive-security.com/metasploit-unleashed/john-ripper/","warftpd_165_user (Keylogging)":"https://www.offensive-security.com/metasploit-unleashed/keylogging/","3proxy (Backdoor)":"https://www.offensive-security.com/metasploit-unleashed/meterpreter-backdoor/","persistence.rb (Persistent Backdoor)":"https://www.offensive-security.com/metasploit-unleashed/meterpreter-service/","Enabling Remote Desktop":"https://www.offensive-security.com/metasploit-unleashed/enabling-remote-desktop/","Post Exploitation in Linux with Metasploit":"https://pentestlab.blog/2013/01/04/post-exploitation-in-linux-with-metasploit/","Post Exploitation Metasploit Modules Reference":"https://www.infosecmatter.com/post-exploitation-metasploit-modules-reference/","Hack Like Pro: Kill and Disable Antivirus Software Remote PC":"https://null-byte.wonderhowto.com/how-to/hack-like-pro-kill-and-disable-antivirus-software-remote-pc-0141906/","Armitage Post Exploitation":"https://www.offensive-security.com/metasploit-unleashed/armitage-post-exploitation/","Setup Armitage as a Command & Control Framework for Free":"https://infosecwriteups.com/setup-armitage-as-a-command-control-c2-framework-for-free-bae590064817","Event Log Management":"https://www.offensive-security.com/metasploit-unleashed/event-log-management","Interacting with the Registry":"https://www.offensive-security.com/metasploit-unleashed/interacting-registry"},"Metasploit-Framework writeup.writeup")
        else:
            return

def LinPeas():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("LinPeas")
        banner.description("LinPeas is a script that automates the process of gathering information about a Linux system, similar to Windows' PowerShell script PEAS. This script can help identify potential vulnerabilities and misconfigurations on a Linux system, as well as provide information about system and network configuration. It can be useful for penetration testing, security assessments, and incident response. The script can be executed with arguments to specify which information to gather, or without arguments to gather all available information\n")
        ask=tool_writeups()
        if ask=="1":
                if os.path.isfile("linpeas.sh"):
                    print(f"{colors.green}[+] Downloaded")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    os.system("chmod +x linpeas.sh && ./linpeas.sh")
                else:
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute LinPeas Script Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("wget --no-verbose https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh && chmod +x linpeas.sh && ./linpeas.sh")
                waiting.waiting()
            
        elif ask=="2":
            writeup.writeup({"LinPeas Blog":"https://blog.cyberethical.me/linpeas","Linux-Privilege-Escalation":"https://delinea.com/blog/linux-privilege-escalation","Linux Privilege Escalation: Quick and Dirty":"https://johnjhacking.com/blog/linux-privilege-escalation-quick-and-dirty/","Outrunsec LinPeas":"https://outrunsec.com/tag/linpeas/","Linux-Privilege-Escalation-Suid-Binaries":"https://steflan-security.com/linux-privilege-escalation-suid-binaries"},"LinPeas writeup.writeup")
        else:
            return

def LinEnum():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("LinEnum")
        banner.description("LinEnum is a Linux enumeration script that can be used to enumerate information from a Linux system. It is designed to be run locally on a Linux system and will attempt to enumerate common files, folders, users, groups, services, configurations, and permissions. It can also be used to look for certain security vulnerabilities such as local privilege escalation. LinEnum can be run from the command line or can be automated using a script. The output of the script can be saved as a text file for later analysis.\n")
        ask=tool_writeups()
        if ask=="1":
                if os.path.isfile("LinEnum.sh"):
                    print(f"{colors.green}[+] Downloaded")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    os.system("chmod +x LinEnum.sh && ./LinEnum.sh")
                else:
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute LinEnum Script Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("curl -s https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -o LinEnum.sh && chmod +x LinEnum.sh && ./LinEnum.sh")
                waiting.waiting()
            
        elif ask=="2":
            writeup.writeup({"Use-LinEnum-Identify-Potential-Privilege-Escalation-Vectors":"https://null-byte.wonderhowto.com/how-to/use-linenum-identify-potential-privilege-escalation-vectors-0197225/","Linux-Privilege-Escalation-With-LinEnum":"https://trevorxcohen.medium.com/linux-privilege-escalation-with-linenum-75d20a3b59f6","LinEnum-Linux-Enumeration-Privilege-Escalation-Tool":"https://www.darknet.org.uk/2014/11/linenum-linux-enumeration-privilege-escalation-tool","Linux-Privilege-Escalation-Quick-And-Dirty":"https://johnjhacking.com/blog/linux-privilege-escalation-quick-and-dirty","Linux Enumeration And Privilege Escalation – LinEnum":"https://vulners.com/n0where/N0WHERE:24819"},"LinEnum writeup.writeup")
        else:
            return
        
def SudoKiller():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Sudo Killer")
        github_text_6 = github_getting_text("https://github.com/TH3xACE/SUDO_KILLER",'p[dir="auto"]',6)
        github_text_7 = github_getting_text("https://github.com/TH3xACE/SUDO_KILLER",'p[dir="auto"]',7)
        merged_text = github_text_6 + github_text_7
        banner.description(merged_text)
        
        ask=tool_writeups()
        if ask=="1":
                if not os.path.isdir("SUDO_KILLER"):
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute SudoKiller Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("git clone https://github.com/TH3xACE/SUDO_KILLER.git")
                        os.system("cd SUDO_KILLER && chmod u+x * && ./SUDO_KILLERv2.4.2.sh")
                    waiting.waiting()
                else:
                        print(f"{colors.green}[+] Installed")
                        print(f"[+] It Is Already Installed{colors.reset}")
                        download = input(f"{colors.blue}Do You Want To Run The Tool?(y/n):{colors.reset}")
                        if download == "y" or download == "Y" or download == "Yes" or download == "yes":
                            os.system("cd SUDO_KILLER && chmod u+x * && ./SUDO_KILLERv2.4.2.sh")
                            waiting.waiting()
            
        elif ask=="2":
            writeup.writeup({"SUDO_KILLER-Demos":"https://github.com/TH3xACE/SUDO_KILLER#demos","Sudo-Killer Briskinfosec":"https://www.briskinfosec.com/tooloftheday/toolofthedaydetail/SUDO-KILLER","Sudo-Killer-Identify-Abuse-Sudo-Misconfigurations":"https://null-byte.wonderhowto.com/how-to/use-sudo-killer-identify-abuse-sudo-misconfigurations-0202594"},"LinEnum writeup.writeup")
        else:
            return

def Beroot():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Beroot")
        github_text_0 = github_getting_text("https://github.com/AlessandroZ/BeRoot",'p[dir="auto"]',0)
        github_text_1 = github_getting_text("https://github.com/AlessandroZ/BeRoot",'p[dir="auto"]',1)
        merged_text = github_text_0 + github_text_1
        banner.description(merged_text)
        ask=tool_writeups()
        if ask=="1":
                if not os.path.isdir("BeRoot"):
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute BeRoot Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("git clone https://github.com/AlessandroZ/BeRoot.git")
                        os.system("cd BeRoot/Linux && chmod u+x * && ./beroot.py")
                    waiting.waiting()
                else:
                        print(f"{colors.green}[+] Installed")
                        print(f"[+] It Is Already Installed{colors.reset}")
                        download = input(f"{colors.blue}Do You Want To Run The Tool?(y/n):{colors.reset}")
                        if download == "y" or download == "Y" or download == "Yes" or download == "yes":
                            os.system("cd BeRoot/Linux && chmod u+x * && ./beroot.py")
                            waiting.waiting()
            
        elif ask=="2":
            writeup.writeup({"BeRoot-Linux-Privilege-Escalation":"https://www.kitploit.com/2018/06/beroot-for-linux-privilege-escalation.html?m=0","BeRoot-A-Post-Exploitation-Privilege-Escalation-Tool":"https://latesthackingnews.com/2019/08/02/beroot-a-post-exploitation-privilege-escalation-tool","BeRoot-Windows-Privilege-Escalation":"https://securityonline.info/beroot-windows-privilege-escalation"},"BeRoot writeup.writeup")
        else:
            return

def LinuxExploitSuggester():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Linux Exploit Suggester 2")
        banner.description("Linux Exploit Suggester 2 (LES 2) is a tool that can be used to identify potential vulnerabilities and exploits that can be used to compromise a Linux system. It works by analyzing the running kernel version and system information, and then comparing it to a local database of known vulnerabilities and exploits. LES 2 can also be used to determine whether a patch has been applied to a specific vulnerability, making it useful for identifying systems that are still vulnerable to known exploits. The tool is open-source and can be easily installed on a Linux system. It supports a wide range of Linux distributions, including Ubuntu, Debian, Fedora, Arch Linux and more. LES 2 is a command-line tool and requires Python to run.It's a useful tool for penetration testers and system administrators to identify and prioritize vulnerabilities on their systems.\n")
        
        ask=tool_writeups()
        if ask=="1":
                if not os.path.isdir("linux-exploit-suggester-2"):
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute Linux-Exploit-Suggester-2 Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("git clone https://github.com/jondonas/linux-exploit-suggester-2.git")
                        os.system("cd linux-exploit-suggester-2 && chmod u+x linux-exploit-suggester-2.pl && ./linux-exploit-suggester-2.pl")
                    waiting.waiting()
                else:
                        print(f"{colors.green}[+] Installed")
                        print(f"[+] It Is Already Installed{colors.reset}")
                        download = input("Do You Want To Run The Tool?(y/n):")
                        if download == "y" or download == "Y" or download == "Yes" or download == "yes":
                            os.system("cd linux-exploit-suggester-2 && chmod u+x linux-exploit-suggester-2.pl && ./linux-exploit-suggester-2.pl")
                            waiting.waiting()

            
        elif ask=="2":
            writeup.writeup({"Kali Tools (linux-exploit-suggester)":"https://www.kali.org/tools/linux-exploit-suggester/","Find-Exploits-Get-Root-With-Linux-Exploit-Suggester":"https://null-byte.wonderhowto.com/how-to/find-exploits-get-root-with-linux-exploit-suggester-0206005","Pentest-Monkey Linux-Exploit-Suggester":"https://pentestmonkey.net/tools/audit/exploit-suggester","Linux-Exploit-Suggester-A-Kali-Linux-Tool-To-Find-The-Linux-Os-Kernel-Exploits":"https://gbhackers.com/linux-exploit-suggester-a-kali-linux-tool-to-find-the-linux-os-kernel-exploits","Securityonline Linux-Exploit Suggester":"https://securityonline.info/linux-exploit-suggester-2"},"Linux-Exploit-Suggester-2 writeup.writeup")
        else:
            return

def LSE():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("LSE (Linux Smart Enumeration)")
        banner.description("Linux Smart Enumeration (LSE) is a script written by Diego Treitos that automates the enumeration process for Linux systems. It is designed to run quickly and efficiently, and to provide detailed information about the system, including users, groups, permissions, network configuration, and more. LSE is intended to be used by penetration testers and security professionals to gather information about a target system during the reconnaissance phase of an engagement.")
        ask=tool_writeups()
        if ask=="1":
                if not os.path.isdir("linux-smart-enumeration"):
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute LSE (Linux Smart Enumeration) Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("git clone https://github.com/diego-treitos/linux-smart-enumeration.git")
                        os.system("cd linux-smart-enumeration && chmod u+x lse.sh && ./lse.sh")
                    waiting.waiting()
                else:
                    print(f"{colors.green}[+] Installed")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    download = input(f"{colors.blue}Do You Want To Run The Tool?(y/n):{colors.reset}")
                    if download == "y" or download == "Y" or download == "Yes" or download == "yes":
                        os.system("cd linux-smart-enumeration && chmod u+x lse.sh && ./lse.sh")
                        waiting.waiting()
            
        elif ask=="2":
            writeup.writeup({"Documentation (linux-smart-enumeration)":"https://github.com/diego-treitos/linux-smart-enumeration/blob/master/README.md","Use-Linux-Smart-Enumeration-Discover-Paths-Privesc":"https://null-byte.wonderhowto.com/how-to/use-linux-smart-enumeration-discover-paths-privesc-0330807","Hakin9 linux-smart-enumeration":"https://hakin9.org/linux-smart-enumeration"},"Linux-Smart-Enumeration writeup.writeup")
        else:
            return
        
def PSPY():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("PSPY")
        github_text_0=github_getting_text("https://github.com/DominicBreuker/pspy",'p[dir="auto"]',2)
        github_text_1=github_getting_text("https://github.com/DominicBreuker/pspy",'p[dir="auto"]',3)
        merged_text = github_text_0 + github_text_1
        banner.description(merged_text)
        ask=tool_writeups()
        if ask=="1":
                if os.path.isfile("pspy64"):
                    print(f"{colors.green}[+] Downloaded")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    os.system("chmod u+x pspy64 && ./pspy64")
                    waiting.waiting()
                else:
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute PSPY Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        print(f"{colors.blue}Downloading... Please Wait !! {colors.reset}")
                        os.system("wget --no-verbose https://github.com/DominicBreuker/pspy/releases/download/v1.2.1/pspy64")
                        os.system("chmod u+x pspy64 && ./pspy64")
                    waiting.waiting()
            
        elif ask=="2":
            writeup.writeup({"Using-PSPY-To-Monitor-Linux-Processes":"https://infinitelogins.com/2020/09/04/using-ps-py-to-monitor-linux-processes","Cyberkendra Pspy-Tool-Monitor-Linux-Processes":"https://tools.cyberkendra.com/2020/04/pspy-tool-monitor-linux-processes.html","How-To-Enumerate-Services-In-Use-With-PSPY":"https://vk9-sec.com/how-to-enumerate-services-in-use-with-pspy","TryHackMe-ConvertMyVideo writeup.writeup":"https://sparshjazz.medium.com/tryhackme-convertmyvideo-writeup.writeup-56b6c8217001","Bootlesshacker PSPY":"https://www.bootlesshacker.com/tag/pspy","SecurityOnline PSPY":"https://securityonline.info/pspy"},"PSPY writeup.writeup")
        else:
            return

def Bashark():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Bashark")
        banner.description("Bashark is an open-source tool developed by redcode-labs that allows you to perform reconnaissance on a target by using various command-line tools and APIs. It can be used to gather information about a target's IP address, DNS information, WHOIS information, and more. Bashark is written in Bash and can be run on Linux and macOS systems. It is commonly used by penetration testers and security researchers to gather information during the reconnaissance phase of a penetration testing engagement")
        ask=tool_writeups()
        if ask=="1":
                if not os.path.isfile("bashark.sh"):
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute Bashark Script Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("curl -s https://raw.githubusercontent.com/redcode-labs/Bashark/master/bashark.sh -o bashark.sh && chmod u+x bashark.sh && ./bashark.sh")
                        print("To Run This Tool Use \033[1;32;40m source bashark.sh \033[0m this command in the Terminal ")
                    waiting.waiting()
                else:
                    print(f"{colors.green}[+] Installed")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    download = input(f"{colors.blue}Do You Want To Run The Tool?(y/n):{colors.reset}")
                    if download == "y" or download == "Y" or download == "Yes" or download == "yes":
                        os.system("chmod u+x bashark.sh && ./bashark.sh")
                        print("To Run This Tool Use \033[1;32;40m source bashark.sh \033[0m this command in the Terminal ")
                        waiting.waiting()
                    else:
                        pass
            
        elif ask=="2":
            writeup.writeup({"Documentation":"https://github.com/redcode-labs/Bashark/blob/master/README.md","SecurityOnline-Bashark":"https://securityonline.info/bashark/","Bashark-Bash-Post-Exploitation-Toolkit":"https://www.kitploit.com/2018/10/bashark-bash-post-exploitation-toolkit.html"},"Bashark writeup.writeup")
        else:
            return

def LinuxPrivatei():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Linux-Private-i")
        banner.description("A Linux Enumeration & Privilege Escalation tool that automates the basic enumeration steps and displays the results in an easily readable format. The script comes loaded with a variety of 4 Options to choose from. Using Bash, execute private-i.sh on the local low privileged user. Select an option, execute & watch the show. Each mode uses common Linux binaries to enumerate the local system (find, grep, ps, etc). If you have a non-bash shell such as sh, use Noir-Private-i. Either script will not write or auto-exploit in any way.")
        ask=tool_writeups()
        if ask=="1":
                if os.path.isfile('private-i.sh'):
                    print(f"{colors.green}[+] Installed")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    os.system("chmod +x private-i.sh && ./private-i.sh")
                    waiting.waiting()
                else:
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute Linux-Private-i Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("curl -s https://raw.githubusercontent.com/rtcrowley/linux-private-i/master/private-i.sh -o private-i.sh && chmod u+x private-i.sh && ./private-i.sh")
                    waiting.waiting()
                    
        elif ask=="2":
            writeup.writeup({"Documentation":"https://github.com/rtcrowley/linux-private-i/blob/master/README.md","HackingArticles-linux-privilege-escalation-automated-script":"https://www.hackingarticles.in/linux-privilege-escalation-automated-script"},"Linux-Private-i writeup.writeup")
        else:
            return

def Shellter():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Shellter")
        banner.description("Shellter is a dynamic shellcode injection tool aka dynamic PE infector. It can be used in order to inject shellcode into native Windows applications (currently 32-bit apps only). The shellcode can be something yours or something generated through a framework, such as Metasploit. Shellter takes advantage of the original structure of the PE file and doesn't apply any  modification such as changing memory access permissions in sections (unless the user wants to), adding an extra section with RWE access, and whatever would look dodgy under an AV scan. Shellter is not just an EPO infector that tries to find a location to insert an instruction to redirect execution to the payload. Unlike any other infector, Shellter’s advanced infection engine never transfers the execution flow to a code cave or to an added section in the infected PE file. Shellter uses a unique dynamic approach which is based on the execution flow of the target application. This means that no static/predefined locations are used for shellcode injection. Shellter will launch and trace the target, while at the same time will log the execution flow of the application.\n")
        ask=tool_writeups()
        if ask=="1":
                check_installed("shellter","shellter")
        elif ask=="2":
            #first argument for dictionary(key=title,value=url) second argument for banner 
            writeup.writeup({"Introduction to Shellter": "https://github.com/ParrotSec/shellter#readme","Tool documentation for Shellter on Kali Linux": "https://www.kali.org/tools/shellter/#tool-documentation","Anti-virus Bypass with Shellter 5.1 on Kali Linux": "https://cyberarms.wordpress.com/2015/10/04/anti-virus-bypass-with-shellter-5-1-on-kali-linux/","Shellter: A Shellcode Injecting Tool": "https://www.hackingarticles.in/shellter-a-shellcode-injecting-tool/","Shellter - The Ultimate Tool for AV Evasion": "https://metalkey.github.io/shellter---the-ultimate-tool-for-av-evasion.html","Hack like a Pro: Evade AV Software with Shellter": "https://null-byte.wonderhowto.com/how-to/hack-like-pro-evade-av-software-with-shellter-0168504/"},"Shellter writeup.writeup")
        else:
            return

def Amber():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Amber")
        github_text_0=github_getting_text("https://github.com/EgeBalci/amber",'p[dir="auto"]',1)
        banner.description(github_text_0)
        ask=tool_writeups()
        if ask=="1":
                if not os.path.isdir("amber_linux_amd64_3.1"):
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute Amber Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("wget --no-verbose https://github.com/EgeBalci/amber/releases/download/v3.1/amber_linux_amd64_3.1.zip 2>/dev/null")
                        os.system("unzip -qq amber_linux_amd64_3.1.zip && cd amber_linux_amd64_3.1 && chmod u+x amber && ./amber")
                    waiting.waiting()
                else:
                    print(f"{colors.green}[+] Installed")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    download = input(f"{colors.blue}Do You Want To Run The Tool?(y/n):{colors.reset}")
                    if download == "y" or download == "Y" or download == "Yes" or download == "yes":
                        os.system("cd amber_linux_amd64_3.1 && chmod u+x amber && ./amber")
                        waiting.waiting()
                    else:
                        pass
            
        elif ask=="2":
            writeup.writeup({"Amber README":"https://github.com/EgeBalci/amber/blob/master/README.md","Amber Video - 1 ":"https://www.youtube.com/watch?v=3en0ftnjEpE","Amber Video - 2 ":"https://www.youtube.com/watch?v=lCPdKSH6RMc","Amber Usage":"https://raw.githubusercontent.com/EgeBalci/amber/master/img/usage.gif"},"Amber writeup.writeup")
        else:
            return

def UPX():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("UPX (Ultimate Packer for Executable)")
        banner.description("UPX is a free, portable, extendable, high-performance executable packer for several different executable formats. It can be used to compress and obfuscate executable files to make them smaller and more difficult to reverse engineer. UPX supports a wide range of file formats, including Windows PE, Linux ELF, and more. UPX is available for a variety of platforms, including Windows, Linux, and macOS. The UPX compression algorithm is designed to compress the code section of an executable file, while leaving the data section uncompressed. This allows the compressed code to be executed directly from memory without the need to decompress it first. UPX is open-source and actively maintained, with updates and bug fixes released regularly.\n")
        ask=tool_writeups()
        if ask=="1":
                if not os.path.isdir("upx-4.0.1-i386_linux"):
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute UPX (Ultimate Packer for Executable) Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        os.system("wget --no-verbose https://github.com/upx/upx/releases/download/v4.0.1/upx-4.0.1-i386_linux.tar.xz 2>/dev/null")
                        os.system("tar -xf upx-4.0.1-i386_linux.tar.xz && cd upx-4.0.1-i386_linux && chmod u+x upx && ./upx")
                    waiting.waiting()
                else:
                    print(f"{colors.green}[+] Installed")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    download = input(f"{colors.blue}Do You Want To Run The Tool?(y/n):{colors.reset}")
                    if download == "y" or download == "Y" or download == "Yes" or download == "yes":
                        os.system("cd upx-4.0.1-i386_linux && chmod u+x upx && ./upx")
                        waiting.waiting()
                    else:
                        pass
            
        elif ask=="2":
            writeup.writeup({"UPX README":"https://github.com/upx/upx#readme","UPX Video - 1 ":"https://www.youtube.com/watch?v=upTXpDhI0ww"},"UPX writeup.writeup")
        else:
            return

def Covermyass():
    while True:
        os.system("clear")
        banner.main()
        banner.attack("Covermyass")
        github_text=github_getting_text("https://github.com/sundowndev/covermyass",'p[dir="auto"]',1)
        banner.description(github_text)
        ask=tool_writeups()
        if ask=="1":
                if os.path.isfile('covermyass_linux_amd64'):
                    print(f"{colors.green}[+] Installed")
                    print(f"[+] It Is Already Installed{colors.reset}")
                    os.system("chmod +x covermyass_linux_amd64 && ./covermyass_linux_amd64")
                    waiting.waiting()
                else:
                    ask_install=input(f"{colors.blue}[+] Do You Want To Download & Execute Covermyass Or Not?(y/n):{colors.reset}")
                    if ask_install=="y" or ask_install=="Y" or ask_install=="Yes" or ask_install=="yes":
                        print(f"{colors.blue}Downloading ...{colors.reset}")
                        os.system("wget --no-verbose https://github.com/sundowndev/covermyass/releases/download/v2.0.0-beta4/covermyass_linux_amd64 2>/dev/null")
                        os.system("chmod u+x covermyass_linux_amd64 && ./covermyass_linux_amd64")
                    waiting.waiting()
                    
        elif ask=="2":
            writeup.writeup({"CoverMyAss README":"https://github.com/sundowndev/covermyass/blob/master/README.md","Clearing or Removing Tracks":"https://b14cky-notes.gitbook.io/untitled/"},"CoverMyAss writeup.writeup")
        else:
            return
        
def tool_writeups():
    print(f"{colors.options}1) TOOL(About,Installation)")
    print(f"2) Write Ups")
    print(f"3) Go Back..")
    ask=input(f"\n {colors.select}Select An Option ->{colors.reset}  ")
    return ask

if __name__ == "__main__": 
    main()
